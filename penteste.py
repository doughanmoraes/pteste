import os
import requests
import whois
import subprocess
import nmap
import geoip2.database
import csv



def check_site_availability(url):
    try:
        response = requests.get(url, timeout=10)
        return response.status_code == 200
    except requests.RequestException:
        return False
    
def perform_nmap_scan(target):
    nmap_path = r"C:\Program Files (x86)\Nmap\nmap.exe"  # Substitua pelo seu caminho se necessário
    
    try:
        # Execute o Nmap com o caminho completo
        result = subprocess.run([nmap_path, '-sS', target], capture_output=True, text=True)
        if result.returncode != 0:
            print(f"Erro ao fazer scan Nmap: {result.stderr}")
            return None
        return result.stdout
    except FileNotFoundError:
        print("Nmap não encontrado no caminho especificado.")
        return None

def analyze_vulnerabilities(headers, open_ports, nikto_report):
    vulnerabilities = []

    # Análise dos cabeçalhos de segurança
    if headers['CSP'] == 'Absent':
        vulnerabilities.append({
            'Vulnerability': 'Content-Security-Policy (CSP) Ausente',
            'Gravidade': 'Alta',
            'Exploração': 'Injeção de código malicioso (XSS) pode ser feita em seu site.',
            'Solução': 'Implemente uma Política de Segurança de Conteúdo (CSP).'
        })
    if headers['X-XSS-Protection'] == 'Absent':
        vulnerabilities.append({
            'Vulnerability': 'X-XSS-Protection Ausente',
            'Gravidade': 'Alta',
            'Exploração': 'Seu site pode estar vulnerável a ataques XSS (Cross-Site Scripting).',
            'Solução': 'Adicione o cabeçalho X-XSS-Protection para proteção contra XSS.'
        })
    if headers['Strict-Transport-Security'] == 'Absent':
        vulnerabilities.append({
            'Vulnerability': 'Strict-Transport-Security (HSTS) Ausente',
            'Gravidade': 'Média',
            'Exploração': 'Um invasor pode forçar uma conexão HTTP e capturar dados transmitidos.',
            'Solução': 'Implemente HSTS para garantir que o site sempre use HTTPS.'
        })
    if headers['X-Frame-Options'] == 'Absent':
        vulnerabilities.append({
            'Vulnerability': 'X-Frame-Options Ausente',
            'Gravidade': 'Média',
            'Exploração': 'O site pode ser alvo de ataques de Clickjacking.',
            'Solução': 'Adicione o cabeçalho X-Frame-Options para impedir o carregamento em frames externos.'
        })

    # Análise de portas abertas
    if open_ports:
        for item in open_ports:
            if len(item) == 2:  # Verifica se temos uma tupla com 2 elementos
                port, state = item
                vulnerabilities.append({
                    'Vulnerability': f'Porta {port} aberta',
                    'Gravidade': 'Alta' if port in [22, 80, 443] else 'Média',
                    'Exploração': f'A porta {port} pode ser explorada se o serviço estiver vulnerável.',
                    'Solução': f'Feche a porta {port} ou restrinja o acesso se não for necessária.'
                })

    # Análise do relatório Nikto
    if "vulnerability" in nikto_report.lower():
        vulnerabilities.append({
            'Vulnerability': 'Vulnerabilidades encontradas pelo Nikto',
            'Gravidade': 'Alta',
            'Exploração': 'Nikto encontrou vulnerabilidades conhecidas no site.',
            'Solução': 'Revise o relatório do Nikto para detalhes específicos de cada vulnerabilidade.'
        })

    return vulnerabilities

def get_whois_info(url):
    try:
        w = whois.whois(url)
        return {
            'Registrar': w.registrar,
            'Creation Date': str(w.creation_date),
            'Expiration Date': str(w.expiration_date),
        }
    except Exception as e:
        return f"Erro ao obter WHOIS: {str(e)}"

def check_security_headers(url):
    try:
        response = requests.get(url, timeout=10)
        headers = response.headers
        return {
            'CSP': headers.get('Content-Security-Policy', 'Absent'),
            'X-XSS-Protection': headers.get('X-XSS-Protection', 'Absent'),
            'Strict-Transport-Security': headers.get('Strict-Transport-Security', 'Absent'),
            'X-Frame-Options': headers.get('X-Frame-Options', 'Absent')
        }
    except requests.RequestException as e:
        return f"Erro ao verificar cabeçalhos de segurança: {str(e)}"

def run_nikto_scan(url):
    try:
        result = subprocess.run(['nikto', '-h', url], capture_output=True, text=True)
        return result.stdout
    except Exception as e:
        return f"Erro ao executar Nikto: {str(e)}"

def get_geo_info(ip_address):
    try:
        reader = geoip2.database.Reader('GeoLite2-City.mmdb')
        response = reader.city(ip_address)
        return {
            'Country': response.country.name,
            'City': response.city.name,
            'Latitude': response.location.latitude,
            'Longitude': response.location.longitude,
        }
    except Exception as e:
        return f"Erro ao obter GeoIP: {str(e)}"

def perform_security_tests(url):
    is_online = check_site_availability(url)
    if not is_online:
        return {'Erro': f"O site {url} não está acessível"}

    whois_info = get_whois_info(url)
    headers = check_security_headers(url)
    open_ports = perform_nmap_scan(url)
    nikto_report = run_nikto_scan(url)

    # Aqui você pode incluir a GeoIP se necessário
    geo_info = {}  # Preencha com dados de GeoIP conforme necessário

    vulnerabilities = analyze_vulnerabilities(headers, open_ports, nikto_report)

    return {
        'URL': url,
        'WHOIS': whois_info,
        'GeoIP': geo_info,
        'Security Headers': headers,
        'Open Ports': open_ports,
        'Nikto Report': nikto_report,
        'Vulnerabilities': vulnerabilities
    }

def save_to_csv(results, filename):
    with open(filename, mode='w', newline='', encoding='utf-8') as csv_file:
        writer = csv.writer(csv_file)
        # Write header
        writer.writerow(['URL', 'WHOIS', 'GeoIP', 'Security Headers', 'Open Ports', 'Nikto Report', 'Vulnerabilities'])
        for result in results:
            writer.writerow([
                result['URL'],
                result['WHOIS'],
                result['GeoIP'],
                result['Security Headers'],
                result['Open Ports'],
                result['Nikto Report'],
                result['Vulnerabilities']
            ])

# Read URLs from file and perform tests
results = []
if os.path.exists('url.txt'):
    with open('url.txt', 'r') as file:
        urls = [line.strip() for line in file.readlines()]

    for url in urls:
        print(f"\nIniciando teste para: {url}")
        result = perform_security_tests(url)
        results.append(result)

    # Save results to CSV
    save_to_csv(results, 'security_test_results.csv')
else:
    print("Arquivo url.txt não encontrado.")
